<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Cambiado el título de la pestaña -->
    <title>Generador Banco Preguntas GIFT Moodle</title>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <!-- Font Awesome CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        body {
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
             max-width: 900px;
             background-color: #ffffff;
             padding: 30px;
             border-radius: 8px;
             box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .question-container {
            border: 1px solid #dee2e6;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            background-color: #fff;
        }
        .question-container:hover {
            background-color: #f1f3f5;
            border-color: #adb5bd;
        }
        .question-container.selected {
            background-color: #e7f5ff;
            border-color: #91d5ff;
        }
        .answer-option {
            margin-left: 20px;
            padding: 3px 0;
        }
        .answer-option i {
             font-size: 0.9em;
             width: 18px;
        }
        .question-checkbox {
            display: none;
        }
         #model-loading-indicator, #model-error-message {
             margin-top: 5px;
             font-size: 0.9em;
        }
        #show-api-key {
             border-left: 0;
        }
        .download-buttons {
            margin-top: 15px;
            margin-bottom: 25px;
            display: flex;
            gap: 10px;
        }
        /* Estilo opcional para feedback */
        .feedback-text {
            color: #6c757d; /* Gris estándar de Bootstrap */
            font-style: italic;
            font-size: 0.9em;
        }
        /* Ocultar elementos relacionados con OM por defecto si es necesario,
           aunque JS se encargará de mostrarlos/ocultarlos.
           La clase .om-option se usa como selector en JS. */
        /* .om-option { display: block; } /* Opcional: asegurar que son visibles por defecto */

    </style>
</head>
<body>
    <div class="container">
        <!-- TÍTULO PRINCIPAL MODIFICADO -->
        <h1 class="mb-4 text-center">Generador Banco Preguntas GIFT Moodle</h1>

        <!-- API Key Input -->
        <div class="form-group">
            <label for="gemini-api-key">Clave API de Gemini:
                <a href="https://makersuite.google.com/app/apikey" target="_blank" rel="noopener noreferrer" title="Obtener una clave API de Google AI Studio">
                    <i class="fas fa-question-circle text-muted"></i>
                </a>
            </label>
            <div class="input-group">
                <input type="password" class="form-control" id="gemini-api-key" placeholder="Ingresa tu clave API de Gemini aquí">
                <div class="input-group-append">
                    <button class="btn btn-outline-secondary" type="button" id="show-api-key" title="Mostrar/Ocultar Clave API">
                        <i class="fas fa-eye"></i>
                    </button>
                </div>
            </div>
             <div id="model-error-message" class="text-danger" style="display: none;"></div>
             <div id="model-loading-indicator" class="text-muted" style="display: none;">
                 <i class="fas fa-spinner fa-spin"></i> Cargando modelos...
             </div>
        </div>

        <!-- Model Selector -->
        <div class="form-group">
            <label for="gemini-model-select">Modelo Gemini:</label>
            <select class="form-control" id="gemini-model-select" disabled>
                <option value="">Ingresa una API Key válida para cargar modelos</option>
            </select>
        </div>

        <!-- Quiz Topic -->
        <div class="form-group">
            <label for="quiz-topic">Descripción del Tema:</label>
            <textarea class="form-control" id="quiz-topic" rows="4" placeholder="Ej: Conceptos básicos de redes TCP/IP para FP Grado Medio SMR&#10;Ej: Soy un profesor de Inglés. Preguntas en Inglés. Componentes blasicos del Ordenador&#10;Ej: De este texto que te pego a continuación ..."></textarea>
        </div>

        <!-- Question Type Selector - MOVED AND FULL WIDTH -->
        <div class="form-group">
            <label for="question-type">Tipo Pregunta:</label>
            <select class="form-control" id="question-type">
                <option value="multiple-choice" selected>Opción Múltiple</option>
                <option value="true-false">Verdadero/Falso</option>
            </select>
        </div>

        <!-- Configuration Row -->
        <div class="form-row">
             <div class="form-group col-md-3 col-sm-6" id="num-questions-group">
                <label for="num-questions">Nº Preguntas:</label>
                <select class="form-control" id="num-questions">
                    <option value="5">5</option>
                    <option value="10" selected>10</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                    <option value="25">25</option>
                    <option value="30">30</option>
                    <option value="40">40</option>
                    <option value="50">50</option>
                </select>
            </div>
             <div class="form-group col-md-3 col-sm-6 om-option" id="num-answers-group">
                <label for="num-answers">Nº Respuestas (OM):</label>
                <select class="form-control" id="num-answers" title="Número de respuestas para Opción Múltiple">
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4" selected>4</option>
                    <option value="5">5</option>
                </select>
            </div>
            <div class="form-group col-md-3 col-sm-6 om-option" id="allow-multiple-group">
                 <label for="allow-multiple">Múltiples Correctas (OM):</label>
                <select class="form-control" id="allow-multiple" title="Permitir múltiples respuestas correctas para Opción Múltiple">
                    <option value="false" selected>No</option>
                    <option value="true">Sí</option>
                </select>
            </div>
            <div class="form-group col-md-3 col-sm-6 om-option" id="penalty-group">
                <label for="penalty">Penalización (OM):</label>
                <select class="form-control" id="penalty" title="Penalización por respuesta incorrecta (Opción Múltiple)">
                    <option value="0.0" selected>0%</option>
                    <option value="-1.0">-100%</option>
                    <option value="-0.5">-50%</option>
                    <option value="-0.3333333">-33.3%</option>
                    <option value="-0.25">-25%</option>
                    <option value="-0.20">-20%</option>
                </select>
            </div>
        </div>

        <!-- Generate Button -->
        <button class="btn btn-primary btn-block" id="generate-gift">
            <i class="fas fa-magic mr-1"></i> Generar Banco de Preguntas GIFT
        </button>

        <!-- Loading/Error Indicators for Generation -->
        <div id="loading-indicator" class="mt-3 text-center" style="display: none;">
            <i class="fas fa-spinner fa-spin fa-2x text-primary"></i>
            <p class="mt-2">Generando preguntas con Gemini...</p>
        </div>
        <div id="error-message" class="alert alert-danger mt-3" role="alert" style="display: none;">
            <!-- Error message content set via JS -->
        </div>

         <!-- Download Buttons Container -->
        <div class="download-buttons d-flex w-100">
            <a id="download-all-button" class="btn btn-success flex-fill me-2" href="#" download="Preguntas.gift" style="display: none;">
                <i class="fas fa-file-download mr-1"></i> Descargar Todo
            </a>
            <a id="download-selected-button" class="btn btn-info flex-fill" href="#" style="display: none;">
                <i class="fas fa-check-square mr-1"></i> Descargar Selección
            </a>
        </div>

        <!-- Quiz Preview Area -->
        <div id="quiz-preview" class="mt-4" style="display: none;">
             <hr>
            <h2 class="mb-3">Vista Previa de Preguntas</h2>
            <div id="questions-preview">
                <!-- Questions dynamically inserted here -->
            </div>
        </div>
    </div>

    <!-- SCRIPTS -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- Elementos del DOM ---
            const apiKeyInput = document.getElementById('gemini-api-key');
            const showApiKeyButton = document.getElementById('show-api-key');
            const geminiModelSelect = document.getElementById('gemini-model-select');
            const modelLoadingIndicator = document.getElementById('model-loading-indicator');
            const modelErrorMessage = document.getElementById('model-error-message');
            const quizTopicInput = document.getElementById('quiz-topic');
            const generateGiftButton = document.getElementById('generate-gift');
            const loadingIndicator = document.getElementById('loading-indicator');
            const errorMessage = document.getElementById('error-message');
            const downloadAllButton = document.getElementById('download-all-button');
            const downloadSelectedButton = document.getElementById('download-selected-button');
            const quizPreviewDiv = document.getElementById('quiz-preview');
            const questionsPreview = document.getElementById('questions-preview');
            const numQuestionsSelect = document.getElementById('num-questions');
            const questionTypeSelect = document.getElementById('question-type');
            const numAnswersSelect = document.getElementById('num-answers');
            const allowMultipleSelect = document.getElementById('allow-multiple');
            const penaltySelect = document.getElementById('penalty');

            // --- Elementos para ocultar/mostrar condicionalmente ---
            const numQuestionsGroup = document.getElementById('num-questions-group');
            const numAnswersGroup = document.getElementById('num-answers-group');
            const allowMultipleGroup = document.getElementById('allow-multiple-group');
            const penaltyGroup = document.getElementById('penalty-group');
            const omOptions = [numAnswersGroup, allowMultipleGroup, penaltyGroup]; // Array de elementos a ocultar/mostrar

            let giftCodeGlobal = ""; // Almacena el último código GIFT generado

            // --- Función para Actualizar Visibilidad de Opciones ---
            function updateOptionVisibility() {
                const selectedType = questionTypeSelect.value;
                if (selectedType === 'true-false') {
                    omOptions.forEach(el => el.style.display = 'none'); // Oculta opciones OM
                    // Cambia la clase de numQuestionsGroup para que ocupe todo el ancho
                    numQuestionsGroup.classList.remove('col-md-3', 'col-sm-6');
                    numQuestionsGroup.classList.add('col-12');
                } else { // 'multiple-choice'
                    omOptions.forEach(el => el.style.display = 'block'); // Muestra opciones OM
                    // Restaura las clases originales de numQuestionsGroup
                    numQuestionsGroup.classList.remove('col-12');
                    numQuestionsGroup.classList.add('col-md-3', 'col-sm-6');
                }
            }

            // --- Event Listener: Cambio en el Tipo de Pregunta ---
            questionTypeSelect.addEventListener('change', updateOptionVisibility);

            // --- Llamada inicial para establecer el estado correcto al cargar la página ---
            updateOptionVisibility();

            // --- Función para Cargar Modelos de Gemini ---
            async function loadModels(apiKeyToUse) {
                geminiModelSelect.innerHTML = '<option value="">Ingresa API Key para cargar modelos</option>';
                geminiModelSelect.disabled = true;
                modelErrorMessage.style.display = 'none';
                modelLoadingIndicator.style.display = 'none';

                if (!apiKeyToUse) return;

                modelLoadingIndicator.style.display = 'block';

                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${apiKeyToUse}`);

                    if (!response.ok) {
                        let errorMsg = `Error ${response.status}`;
                        try {
                            const errorData = await response.json();
                            errorMsg = errorData.error?.message || errorMsg;
                        } catch { /* Ignore */ }
                        throw new Error(errorMsg);
                    }

                    const data = await response.json();
                    geminiModelSelect.innerHTML = '<option value="">-- Selecciona un modelo --</option>';

                    let defaultModelFound = false;
                    const preferredModelName = "gemini-1.5-flash-latest";

                    if (data.models) {
                        data.models
                            .filter(model => model.supportedGenerationMethods?.includes("generateContent"))
                            .sort((a, b) => (a.displayName || a.name).localeCompare(b.displayName || b.name))
                            .forEach(model => {
                                const option = document.createElement('option');
                                option.value = model.name;
                                option.textContent = model.displayName || model.name;
                                if (model.name.includes(preferredModelName)) {
                                     option.selected = true;
                                     defaultModelFound = true;
                                }
                                geminiModelSelect.appendChild(option);
                            });
                    }

                    if (geminiModelSelect.options.length > 1) {
                         geminiModelSelect.disabled = false;
                         if (!defaultModelFound && geminiModelSelect.options.length > 1) {
                             geminiModelSelect.selectedIndex = 1;
                         }
                    } else {
                        geminiModelSelect.innerHTML = '<option value="">No se encontraron modelos compatibles</option>';
                        throw new Error("No se encontraron modelos compatibles con 'generateContent'.");
                    }

                } catch (error) {
                    console.error("Error al cargar modelos de Gemini:", error);
                    modelErrorMessage.textContent = `Error al cargar modelos: ${error.message}.`;
                    modelErrorMessage.style.display = 'block';
                    geminiModelSelect.innerHTML = '<option value="">Error al cargar</option>';
                    geminiModelSelect.disabled = true;
                } finally {
                    modelLoadingIndicator.style.display = 'none';
                }
            }

            // --- Event Listener: Load Models on API Key Input Blur ---
            apiKeyInput.addEventListener('blur', () => {
                loadModels(apiKeyInput.value.trim());
            });

            // --- Event Listener: Show/Hide API Key ---
            showApiKeyButton.addEventListener('click', () => {
                const isPassword = apiKeyInput.type === "password";
                apiKeyInput.type = isPassword ? "text" : "password";
                showApiKeyButton.innerHTML = isPassword ? '<i class="fas fa-eye-slash"></i>' : '<i class="fas fa-eye"></i>';
            });

            // --- Función para construir el Payload de la API ---
            function buildPayload(prompt) {
                 return JSON.stringify({
                    "contents": [ { "parts": [ { "text": prompt } ] } ],
                    "generationConfig": {
                        "temperature": 0.6,
                        "maxOutputTokens": 8192,
                        "topP": 0.95,
                        "topK": 40
                    },
                     "safetySettings": [
                        { "category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE" },
                        { "category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_MEDIUM_AND_ABOVE" },
                        { "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_MEDIUM_AND_ABOVE" },
                        { "category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE" }
                    ]
                });
            }

            // --- Función para llamar a la API de Gemini (Generar Contenido) ---
            async function callGeminiAPI(payload) {
                const currentApiKey = apiKeyInput.value.trim();
                const selectedModelName = geminiModelSelect.value;

                if (!currentApiKey) throw new Error("Por favor, ingresa tu clave API de Gemini.");
                if (!selectedModelName) throw new Error("Por favor, selecciona un modelo de Gemini.");

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/${selectedModelName}:generateContent?key=${currentApiKey}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: payload
                    });

                    if (!response.ok) {
                        let errorMsg = `Error ${response.status}`;
                        try {
                            const errorData = await response.json();
                            errorMsg = `Error API: ${errorData.error?.message || errorMsg}`;
                        } catch { /* Ignore */ }
                        throw new Error(errorMsg);
                    }
                    const data = await response.json();
                    // console.log("API Response:", data); // Descomentar para depurar
                    return data;
                } catch (error) {
                    console.error("Error en callGeminiAPI:", error);
                    throw new Error(`Fallo al contactar la API de Gemini: ${error.message}`);
                }
            }

             // --- Función para extraer Texto de la Respuesta ---
            function extractResponse(response) {
                if (response?.promptFeedback?.blockReason) {
                    console.error("API Block Reason:", response.promptFeedback.blockReason);
                    throw new Error(`La solicitud fue bloqueada por la API: ${response.promptFeedback.blockReason}. Intenta ajustar el tema.`);
                }
                if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                    return response.candidates[0].content.parts[0].text;
                } else if (response?.candidates?.[0]?.finishReason && response.candidates[0].finishReason !== "STOP") {
                     console.warn("API Finish Reason:", response.candidates[0].finishReason);
                     throw new Error(`La generación no se completó correctamente (Razón: ${response.candidates[0].finishReason}).`);
                } else {
                    console.warn("Respuesta inesperada o vacía:", response);
                    throw new Error("La respuesta de la API de Gemini fue inesperada o está vacía.");
                }
            }

            // --- Función Principal para Generar GIFT ---
             async function generateGIFT(quizTopic, numQuestions, questionType, numAnswers, allowMultiple, penalty) {
                 let prompt = `Eres un experto creando bancos de preguntas Moodle en formato GIFT.
Tema: "${quizTopic}"
Nº Preguntas a generar: ${numQuestions}
Tipo de pregunta solicitado: ${questionType === 'true-false' ? 'Verdadero/Falso' : 'Opción Múltiple'}

**REGLAS ESTRICTAS GENERALES (OBLIGATORIO):**
1.  **Formato GIFT Exacto:** Sintaxis perfecta según el tipo de pregunta.
2.  **Título Obligatorio:** Cada pregunta inicia con '::Título Descriptivo Único::'.
3.  **Enunciado Obligatorio:** Texto claro de la pregunta/afirmación después del título.
4.  **Respuesta Encerrada:** SIEMPRE entre llaves '{ }'.
5.  **Separación:** UNA línea en blanco entre preguntas (desde '::' hasta '}').
6.  **Sin Extras:** NINGÚN texto fuera del formato GIFT (ni antes de la primera '::' ni después de la última '}').
7.  **Sin HTML/Markdown:** El contenido (títulos, enunciados, opciones, feedback) NO DEBE tener <p>, <b>, *, _, etc.

**REGLAS ESPECÍFICAS SEGÚN TIPO:**
`;

                if (questionType === 'true-false') {
                    prompt += `
**PARA PREGUNTAS VERDADERO/FALSO:**
    *   El enunciado debe ser una afirmación clara.
    *   La respuesta debe ser EXACTAMENTE '{T}' para verdadero o '{F}' para falso.
    *   **Retroalimentación Opcional pero Recomendada:** Si se añade, DEBE ir DESPUÉS de T o F con '#'. Ejemplo: '{T#¡Correcto! Es verdadero porque...}' o '{F#¡Incorrecto! Es falso ya que...}'.
    *   NO USAR '~', '=', ni '%'. Solo T o F dentro de las llaves (seguido opcionalmente por #Feedback).

    Ejemplo Verdadero/Falso Correcto:
    ::Ejemplo V/F 1:: El sol gira alrededor de la tierra. {F#Incorrecto, la Tierra gira alrededor del Sol.}

    ::Ejemplo V/F 2:: El agua hierve a 100°C al nivel del mar. {T#Correcto.}
`;
                } else { // multiple-choice
                    prompt += `
**PARA PREGUNTAS DE OPCIÓN MÚLTIPLE:**
    *   Opciones por Pregunta: EXACTAMENTE ${numAnswers}.
    *   Marcadores: Correcta '=', incorrectas '~'.
    *   Retroalimentación Obligatoria: CADA opción DEBE tener feedback con '#'. Ejemplo: '=Opción Correcta #¡Bien!' o '~Opción Incorrecta #Incorrecto porque...'.
    *   Penalización (Solo Incorrectas ~): Aplicar a TODAS las incorrectas (~). Valor: ${penalty * 100}%. Sintaxis: ~%${(penalty * 100).toFixed(1)}%Texto Incorrecto #Feedback.`;

                    const penaltyPercentage = (penalty * 100).toFixed(1);

                    if (allowMultiple === "true") {
                        prompt += `
    *   Múltiples Correctas Permitidas: CADA pregunta debe tener AL MENOS DOS correctas (=).
    *   Puntuación Parcial Obligatoria: Indicar % para CADA correcta: '=%PORCENTAJE%Texto #Feedback'. La suma de % debe ser 100%.
        Ejemplo Múltiple Correcto (Penalización ${penaltyPercentage}%):
        ::Capitales Europeas:: ¿Cuáles de las siguientes son capitales europeas? {
        =%50%París #Correcto, capital de Francia.
        ~%${penaltyPercentage}%Nueva York #Incorrecto, es de EEUU.
        =%50%Berlín #Correcto, capital de Alemania.
        ~%${penaltyPercentage}%Tokio #Incorrecto, es de Japón.
        }`;
                    } else {
                        prompt += `
    *   Única Respuesta Correcta: CADA pregunta debe tener UNA SOLA correcta (=). El resto incorrectas (~).
        Ejemplo Única Correcta (Penalización ${penaltyPercentage}%):
        ::Color del Caballo Blanco:: ¿De qué color era el caballo blanco de Santiago? {
        ~%${penaltyPercentage}%Negro #Incorrecto.
        ~%${penaltyPercentage}%Marrón #Incorrecto.
        =Blanco #Correcto.
        ~%${penaltyPercentage}%Azul #Incorrecto.
        }`;
                    }
                    prompt += `
    *   Variar Posición Correcta: Alternar aleatoriamente la posición de la(s) correcta(s) entre las preguntas.`;
                }

                prompt += `

**INSTRUCCIÓN FINAL:**
Genera EXACTAMENTE ${numQuestions} preguntas del tipo "${questionType === 'true-false' ? 'Verdadero/Falso' : 'Opción Múltiple'}" sobre el tema "${quizTopic}", siguiendo ESTRICTAMENTE las reglas aplicables a ese tipo. Asegúrate de cumplir TODAS las reglas generales y específicas.

**GENERAR BANCO DE PREGUNTAS GIFT AHORA:**
`;
                // console.log("Generated Prompt:", prompt); // Descomentar para depuración del prompt
                const payload = buildPayload(prompt);
                const apiResponse = await callGeminiAPI(payload);
                let giftCode = extractResponse(apiResponse);

                // Limpieza GIFT
                giftCode = giftCode.replace(/```gift/gi, "").replace(/```/g, "");
                giftCode = giftCode.replace(/^\s*[\r\n]/, ''); // Trim leading whitespace/newlines
                giftCode = giftCode.replace(/[\r\n]\s*$/, ''); // Trim trailing whitespace/newlines
                giftCode = giftCode.replace(/[\r\n]{3,}/g, '\n\n'); // Normalize excessive newlines

                giftCodeGlobal = giftCode;
                return giftCode;
            }

             // --- Función para Mostrar Preguntas en la UI ---
            function displayQuestions(giftCode) {
                questionsPreview.innerHTML = ''; // Limpiar vista previa anterior
                quizPreviewDiv.style.display = 'none'; // Ocultar contenedor hasta que haya algo que mostrar
                let questionCounter = 0; // Contador de preguntas válidas mostradas
                let parseErrors = 0; // Contador de errores de parseo

                if (!giftCode || giftCode.trim() === "") {
                    questionsPreview.innerHTML = '<p class="text-muted text-center">No se generaron preguntas o la respuesta estaba vacía.</p>';
                    quizPreviewDiv.style.display = 'block'; // Mostrar el contenedor con el mensaje
                    return 0; // Devolver 0 preguntas válidas
                }

                const questionBlocks = giftCode.split('\n\n'); // Dividir el texto GIFT en bloques de preguntas

                questionBlocks.forEach((questionBlock, index) => {
                     const question = questionBlock.trim(); // Limpiar espacios en blanco del bloque
                     if (question === "") return; // Ignorar bloques vacíos

                     // Crear contenedor principal para la pregunta
                     const questionContainer = document.createElement('div');
                     questionContainer.className = 'question-container';
                     questionContainer.dataset.questionIndex = index; // Guardar índice original para descarga

                     // Crear checkbox (oculto visualmente, usado para selección)
                     const checkbox = document.createElement('input');
                     checkbox.type = 'checkbox';
                     checkbox.className = 'question-checkbox';
                     questionContainer.appendChild(checkbox);

                     // Añadir listener para seleccionar/deseleccionar al hacer clic en el contenedor
                     questionContainer.addEventListener('click', (e) => {
                         // Solo activa el checkbox si se hace clic directamente en el contenedor, título, párrafo, etc.
                         // Evita que se active si se hace clic en elementos interactivos internos (aunque no hay aquí)
                         if (e.target === questionContainer || e.target.closest('.question-container') === questionContainer && !e.target.closest('a, button')) {
                             checkbox.checked = !checkbox.checked;
                             questionContainer.classList.toggle('selected', checkbox.checked);
                         }
                     });

                     // Intentar parsear y mostrar la pregunta
                     try {
                        // Extraer Título
                        const titleMatch = question.match(/^::(.*?)::/);
                        const titleText = titleMatch ? titleMatch[1].trim() : `Pregunta ${index + 1} (Sin Título)`; // Usar índice si no hay título

                        // Extraer Cuerpo (Enunciado) y Opciones
                        const questionBodyMatch = question.match(/^::.*?::\s*([\s\S]*?)\s*\{([\s\S]*?)\}\s*$/);
                        if (!questionBodyMatch) throw new Error("Estructura GIFT básica '::Título:: Cuerpo {Opciones}' no encontrada.");

                        const questionText = questionBodyMatch[1].trim(); // Enunciado o Afirmación
                        const optionsText = questionBodyMatch[2].trim(); // Contenido dentro de {}

                        // --- Pregunta parseable hasta aquí ---
                        questionCounter++; // Incrementar contador de preguntas VÁLIDAS

                        // Mostrar Título
                        const questionTitleEl = document.createElement('h5');
                        questionTitleEl.textContent = titleText;
                        questionContainer.appendChild(questionTitleEl);

                        // Mostrar Enunciado/Afirmación (Sanitizar por si acaso)
                        const questionParagraph = document.createElement('p');
                        const tempDiv = document.createElement('div'); // Usar div temporal para sanitizar texto
                        tempDiv.textContent = questionText;
                        questionParagraph.innerHTML = `<b>${tempDiv.innerHTML}</b>`; // Poner en negrita
                        questionContainer.appendChild(questionParagraph);

                        // Parsear y Mostrar Opciones/Respuesta V/F
                        const optionsList = document.createElement('ul');
                        optionsList.className = 'list-unstyled'; // Quitar bullets de la lista

                        // ---- DETECTAR TIPO V/F ----
                        const upperOptionsText = optionsText.toUpperCase();
                        let isTrueFalse = false;
                        let tfAnswer = '';
                        let tfFeedback = '';

                        if (upperOptionsText === 'T' || upperOptionsText === 'F') {
                            isTrueFalse = true;
                            tfAnswer = upperOptionsText;
                        } else if (upperOptionsText.startsWith('T#')) {
                            isTrueFalse = true;
                            tfAnswer = 'T';
                            tfFeedback = optionsText.substring(2).trim(); // Capturar feedback después de #
                        } else if (upperOptionsText.startsWith('F#')) {
                             isTrueFalse = true;
                             tfAnswer = 'F';
                             tfFeedback = optionsText.substring(2).trim(); // Capturar feedback después de #
                        }
                        // ---- FIN DETECCIÓN V/F ----

                        if (isTrueFalse) {
                            // --- Renderizar como Verdadero/Falso ---
                            const optionItem = document.createElement('li');
                            optionItem.className = 'answer-option';
                            let displayHtml = '';
                            if (tfAnswer === 'T') {
                                displayHtml = '<i class="fas fa-check text-success mr-2" title="Respuesta Correcta: Verdadero"></i> Verdadero';
                            } else {
                                displayHtml = '<i class="fas fa-times text-danger mr-2" title="Respuesta Correcta: Falso"></i> Falso';
                            }
                            // Añadir feedback si existe
                            if (tfFeedback) {
                                tempDiv.textContent = tfFeedback; // Sanitizar feedback
                                displayHtml += ` <small class="feedback-text ml-2">(${tempDiv.innerHTML})</small>`;
                            }
                            optionItem.innerHTML = displayHtml;
                            optionsList.appendChild(optionItem);

                        } else {
                             // --- Renderizar como Opción Múltiple ---
                            const optionLines = optionsText.split('\n').map(line => line.trim()).filter(line => line.startsWith('=') || line.startsWith('~'));

                            if (optionLines.length === 0) throw new Error("No se encontraron líneas de opción válidas (empezando con '=' o '~') para Opción Múltiple.");

                            optionLines.forEach(line => {
                                const optionItem = document.createElement('li');
                                optionItem.className = 'answer-option';
                                const symbol = line.charAt(0); // '=' o '~'
                                let rest = line.substring(1).trim(); // Resto de la línea
                                let percentage = "";
                                let feedback = "";
                                let text = rest;

                                // Extraer feedback (lo que va después de #)
                                const feedbackMatch = rest.match(/^(.*?)#(.*)$/);
                                if (feedbackMatch) {
                                    text = feedbackMatch[1].trim();
                                    feedback = feedbackMatch[2].trim();
                                } else { text = rest; } // Si no hay #, todo es texto

                                // Extraer porcentaje (si existe, entre %%) al inicio del texto de la opción
                                const percentageMatch = text.match(/^%(.*?)%(.*)$/);
                                if (percentageMatch) {
                                    percentage = percentageMatch[1].trim();
                                    text = percentageMatch[2].trim(); // El texto real de la opción
                                }

                                // Construir HTML para la opción
                                let displayHtml = (symbol === '=')
                                    ? '<i class="fas fa-check text-success mr-2" title="Opción Correcta"></i>'
                                    : '<i class="fas fa-times text-danger mr-2" title="Opción Incorrecta"></i>';
                                tempDiv.textContent = text; // Sanitizar texto de la opción
                                displayHtml += tempDiv.innerHTML;

                                // Añadir badges para porcentaje o penalización
                                if (percentage) {
                                    displayHtml += ` <span class="badge badge-info" title="Puntuación Parcial">${percentage}%</span>`;
                                } else if (symbol === '~' && !percentage && parseFloat(penaltySelect.value) !== 0 && questionTypeSelect.value === 'multiple-choice') {
                                    // Mostrar penalización solo si es incorrecta, no tiene %, hay penalización configurada y es tipo OM
                                    displayHtml += ` <span class="badge badge-warning" title="Penalización">${(parseFloat(penaltySelect.value) * 100).toFixed(1)}%</span>`;
                                }

                                // Añadir feedback si existe
                                if (feedback) {
                                    tempDiv.textContent = feedback; // Sanitizar feedback
                                    displayHtml += ` <small class="feedback-text ml-2">(${tempDiv.innerHTML})</small>`;
                                }
                                optionItem.innerHTML = displayHtml;
                                optionsList.appendChild(optionItem);
                            });
                        } // Fin else (Opción Múltiple)

                        questionContainer.appendChild(optionsList); // Añadir lista de opciones/respuesta al contenedor
                        questionsPreview.appendChild(questionContainer); // Añadir contenedor de pregunta válida a la vista previa

                     } catch (parseError) {
                          // --- Manejo de Errores de Parseo ---
                          console.warn(`Error parseando bloque ${index}: "${questionBlock}"`, parseError);
                          parseErrors++;

                          // Crear un contenedor específico para mostrar el error
                          const errorContainer = document.createElement('div');
                          errorContainer.className = 'question-container'; // Mantener estilo similar
                          errorContainer.style.borderColor = 'red';
                          errorContainer.style.backgroundColor = '#f8d7da'; // Fondo rojo claro
                          errorContainer.style.cursor = 'default'; // No seleccionable
                          errorContainer.dataset.questionIndex = index; // Mantener índice para referencia

                          // Mostrar Título (si se pudo extraer) o un título genérico de error
                          const errorTitle = document.createElement('h5');
                          const titleMatch = questionBlock.match(/^::(.*?)::/);
                          errorTitle.textContent = titleMatch ? titleMatch[1].trim() : `Pregunta ${index + 1} (Error de Formato)`;
                          errorContainer.appendChild(errorTitle);

                          // Mostrar mensaje de error
                          const errorP = document.createElement('p');
                          errorP.className = 'text-danger small mt-2';
                          errorP.textContent = `Error al interpretar: ${parseError.message}`;
                          errorContainer.appendChild(errorP);

                          // Mostrar el bloque de código GIFT original que causó el error
                          const codeBlock = document.createElement('pre');
                          codeBlock.textContent = questionBlock;
                          codeBlock.style.fontSize = '0.8em';
                          codeBlock.style.whiteSpace = 'pre-wrap'; // Para que el texto largo se ajuste
                          codeBlock.style.backgroundColor = '#f1f1f1'; // Fondo gris claro para el código
                          codeBlock.style.padding = '10px';
                          codeBlock.style.marginTop = '5px';
                          codeBlock.style.border = '1px dashed #dc3545'; // Borde rojo discontinuo
                          errorContainer.appendChild(codeBlock);

                          questionsPreview.appendChild(errorContainer); // Añadir contenedor de error a la vista previa
                     }
                }); // Fin forEach questionBlocks

                quizPreviewDiv.style.display = 'block'; // Mostrar el área de vista previa

                 // Mostrar resumen de errores si hubo alguno
                 if (parseErrors > 0) {
                      const errorSummary = document.createElement('p');
                      errorSummary.className = 'alert alert-warning small';
                      errorSummary.innerHTML = `<strong>Atención:</strong> Se ${parseErrors === 1 ? 'encontró 1 pregunta' : 'encontraron ' + parseErrors + ' preguntas'} con formato GIFT inválido o errores de interpretación (marcadas en rojo). ${parseErrors === 1 ? 'Esta pregunta no se incluirá' : 'Estas preguntas no se incluirán'} en la "Descarga de Selección" y podrían causar problemas al importar en Moodle. Revisa el formato del texto original mostrado.`;
                      questionsPreview.insertBefore(errorSummary, questionsPreview.firstChild); // Añadir al principio
                 }

                 return questionCounter; // Devolver el número de preguntas que se pudieron mostrar correctamente
            } // Fin displayQuestions


            // --- Event Listener: Botón Generar Cuestionario ---
            generateGiftButton.addEventListener('click', async () => {
                // Resetear estado
                errorMessage.style.display = 'none';
                errorMessage.textContent = '';
                loadingIndicator.style.display = 'block'; // Mostrar indicador de carga
                downloadAllButton.style.display = 'none'; // Ocultar botones de descarga
                downloadSelectedButton.style.display = 'none';
                quizPreviewDiv.style.display = 'none'; // Ocultar vista previa anterior
                questionsPreview.innerHTML = ''; // Limpiar vista previa anterior

                // Obtener valores de configuración
                const quizTopic = quizTopicInput.value.trim();
                const numQuestionsRequested = numQuestionsSelect.value;
                const questionType = questionTypeSelect.value;
                const numAnswers = numAnswersSelect.value;
                const allowMultiple = allowMultipleSelect.value;
                const penalty = parseFloat(penaltySelect.value);

                // Validaciones básicas de entrada
                if (!quizTopic) {
                     errorMessage.textContent = "Por favor, ingresa una descripción para el tema.";
                     errorMessage.style.display = 'block';
                     loadingIndicator.style.display = 'none';
                     return;
                }
                if (!apiKeyInput.value.trim()) {
                    errorMessage.textContent = "Por favor, ingresa tu clave API de Gemini.";
                    errorMessage.style.display = 'block';
                    loadingIndicator.style.display = 'none';
                    return;
                }
                if (!geminiModelSelect.value) {
                     errorMessage.textContent = "Por favor, selecciona un modelo de Gemini. Si no aparecen, reintroduce tu clave API.";
                     errorMessage.style.display = 'block';
                     loadingIndicator.style.display = 'none';
                     return;
                }

                // Llamada asíncrona para generar el GIFT
                try {
                    const giftCode = await generateGIFT(quizTopic, numQuestionsRequested, questionType, numAnswers, allowMultiple, penalty);

                    // Mostrar las preguntas generadas en la UI
                    const validQuestionsCount = displayQuestions(giftCode); // Esta función ahora maneja la vista previa

                    // Habilitar botones de descarga si se generó código y al menos una pregunta es válida
                     if (giftCode.trim() !== "" && validQuestionsCount > 0) {
                        const blobAll = new Blob([giftCode], { type: 'text/plain;charset=utf-8' });
                        const urlAll = URL.createObjectURL(blobAll);
                        downloadAllButton.href = urlAll;
                        downloadAllButton.download = `Preguntas_${validQuestionsCount}.gift`; // Nombre archivo con número de válidas
                        downloadAllButton.style.display = 'inline-block'; // Mostrar botón
                        downloadSelectedButton.style.display = 'inline-block'; // Mostrar botón
                     } else if (validQuestionsCount === 0 && giftCode.trim() !== "") {
                         // Caso: Se generó código pero nada se pudo parsear
                         errorMessage.textContent = "Se generó código GIFT, pero ninguna pregunta pudo ser interpretada correctamente para la vista previa. Revisa los errores marcados en rojo.";
                         errorMessage.style.display = 'block';
                         // Opcionalmente, permitir descargar el código raw
                         const blobAll = new Blob([giftCode], { type: 'text/plain;charset=utf-8' });
                         const urlAll = URL.createObjectURL(blobAll);
                         downloadAllButton.href = urlAll;
                         downloadAllButton.download = `Preguntas_raw_con_errores.gift`;
                         downloadAllButton.textContent = "Descargar Código Generado (con errores)"; // Cambiar texto del botón
                         downloadAllButton.style.display = 'inline-block';
                         downloadSelectedButton.style.display = 'none'; // Ocultar descarga selección

                     }
                      // Si giftCode estaba vacío, displayQuestions ya mostró un mensaje

                } catch (error) {
                    // Manejar errores de la API o de la generación
                    console.error("Error durante la generación o llamada API:", error);
                    errorMessage.textContent = `Error: ${error.message}`;
                    errorMessage.style.display = 'block';
                    quizPreviewDiv.style.display = 'none'; // Asegurar que la vista previa (posiblemente rota) esté oculta
                } finally {
                    // Siempre ocultar el indicador de carga al finalizar
                    loadingIndicator.style.display = 'none';
                }
            });


            // --- Event Listener: Botón Descargar Selección ---
            downloadSelectedButton.addEventListener('click', (event) => {
                event.preventDefault(); // Prevenir comportamiento por defecto del enlace

                let selectedQuestionsGIFT = []; // Array para guardar el texto GIFT de las seleccionadas
                const allQuestionBlocks = giftCodeGlobal.split('\n\n'); // Obtener bloques originales

                // Seleccionar solo los contenedores válidos (sin borde rojo) que estén marcados
                const displayedValidContainers = questionsPreview.querySelectorAll('.question-container:not([style*="border-color: red"])');

                displayedValidContainers.forEach(container => {
                    const checkbox = container.querySelector('.question-checkbox');
                    const originalIndex = container.dataset.questionIndex; // Recuperar índice original

                    // Si está chequeado y tiene un índice válido
                    if (checkbox?.checked && originalIndex !== undefined && allQuestionBlocks[originalIndex]) {
                       selectedQuestionsGIFT.push(allQuestionBlocks[originalIndex].trim()); // Añadir bloque original al array
                    }
                });

                // Si no se seleccionó ninguna pregunta válida
                if (selectedQuestionsGIFT.length === 0) {
                    alert("No has seleccionado ninguna pregunta válida para descargar. Haz clic en las preguntas de la vista previa que NO estén marcadas en rojo.");
                    return;
                }

                // Crear y descargar el archivo
                const selectedGiftCode = selectedQuestionsGIFT.join('\n\n'); // Unir bloques seleccionados con doble salto de línea
                const blob = new Blob([selectedGiftCode], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); // Crear enlace temporal
                a.href = url;
                a.download = `Preguntas_Seleccionadas_${selectedQuestionsGIFT.length}.gift`; // Nombre de archivo dinámico
                document.body.appendChild(a); // Añadir al DOM para poder hacer clic
                a.click(); // Simular clic para iniciar descarga
                document.body.removeChild(a); // Limpiar enlace del DOM
                URL.revokeObjectURL(url); // Liberar memoria del objeto URL
            });

        }); // --- Fin DOMContentLoaded ---
    </script>

    <!-- Bootstrap JS Dependencies (jQuery Slim, Popper.js, Bootstrap JS) -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.3/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>
</html>
